{
  "filename": "blog8.md",
  "__html": "<h2>静态构造函数</h2>\n<p>静态构造函数不能显示调用，它会在类的任何实例被创建之前、类的任何静态成员被引用之前调用。\n静态构造函数不能访问所在类的实例成员(但可以访问静态成员)，因此也不能使用this访问器。</p>\n<pre><code>Class Class1\n{\n\tstatic Class1 ()\n\t{\n\t\t//...\n\t}\n\t//...\n}```\n\n\n## 对象创建可以省略参数\n\n</code></pre>\n<p>new Point(5,6);\n//以下两种{}里面是在初始化实例里时做赋值，且仅能做赋值操作。\nnew Point(){X = 5,Y = 6};\nnew Point{X = 5,Y = 6};```\n以上创建的对象并无区别，但要注意的是，第一种是通过带参构造函数赋值的；其余两种是通过直接对对象字段赋值的，即修饰符必须是public。\n假设Point还有一个公共字段为Z，但是没有带参的构造函数\npublic Point(int X,int Y,int Z){//...};\n那么就不可以用new Point(5,6,7);而是改用new Point(5,6){Z = 7};或是new Point{X = 5,Y = 6,Z = 7}; 后者的代码会更加的清晰。</p>\n<h2>const和readonly</h2>\n<p>简单来说readonly可以修饰实例字段，而const仅能修饰静态字段。\n基于以上原理，被readonly修饰的字段可以在之后赋值，当然同样是只能赋一次值。</p>\n<pre><code>Class Shape{\n\treadonly double PI = 3.1416; //已初始化\n\treadonly int    Number; //未初始化\n\n\tpublic Shape()\n\t{\n\t\tPI = 0;//错误\n\t\tNumber = 1;//正确\n\t}\n}```\n\n\n## 索引器\n\n对象可以包含索引器，索引器不能包括静态字段。\n索引器可以返回指定格式的内容，具体如下：\n</code></pre>\n<p>public Class MyString{\npublic string str1;\npublic string str2;\npublic string str3;</p>\n<pre><code>public string this [int index]\n{\n\tset\n\t{\n\t\tswitch(index){\n\t\t\tcase 0: str1 = value;\n\t\t\t\tbreak;\n\t\t\tcase 1: str2 = value;\n\t\t\t\tbreak;\n\t\t\tcase 2: str3 = value;\n\t\t\t\tbreak;\t\n\t\t\tdefault:\n\t\t\t\tthrow new ArgumentOutOfRangeException(&quot;index&quot;);//超出范围抛异常\n\t\t}\n\t}\n\tget\n\t{\n\t\tswitch(index){\n\t\t\tcase 0: return str1;\n\t\t\t\tbreak;\n\t\t\tcase 1: return str2;\n\t\t\t\tbreak;\n\t\t\tcase 2: return str3;\n\t\t\t\tbreak;\t\n\t\t\tdefault:\n\t\t\t\tthrow new ArgumentOutOfRangeException(&quot;index&quot;);//超出范围抛异常\n\t\t}\n\t}\n}\n</code></pre>\n<p>}\n//调用\nMyString myString = new MyString;\nmyString[0] = &quot;Hello&quot;;\nstring firstStirng = myString[0];```</p>\n<p>索引器是可以重载的，如下：</p>\n<pre><code>class MyClass\n{\n\tpublic string this [int index]\n\t{\n\t\tget{//...}\n\t\tset{//...}\n\t}\n\t\n\tpublic string this [int index,int index2]\n\t{\n\t\tget{//...}\n\t\tset{//...}\n\t}\n\t\n\tpublic int this [float index]\n\t{\n\t\tget{//...}\n\t\tset{//...}\n\t}\n}```\n\n\n## 访问器修饰符\n\n* 仅当成员(属性/索引器) 既有get也有set访问器时，可以添加访问修饰符（private等）\n* get/set访问器只能有一个有访问修饰符\n* 访问器的访问修饰符必须比成员的访问级别有更严格的限制性（即成员是public的，访问器可以设置为private，反之则不行)\n限制性层次：public - protected internal - private\n\n此作用常用于构造函数调用时更改成员值，而外部只能获取值不能修改值。\n</code></pre>\n<p>public Person\n{\npublic string Name{get; private set;}\npublic Person(string name){\nName = name;\n}\n}\n//调用\nPerson p = new Person(&quot;Test&quot;);\nConsole.WriteLine(<a href=\"http://p.Name\">p.Name</a>);</p>\n<pre><code>\n\n## 基类\n\n### 屏蔽基类成员\n\n</code></pre>\n<p>class SomeClass\n{\npublic string MyStr;\n}</p>\n<p>class OtherClass : SomeClass\n{\nnew Public string MyStr;\n}```</p>\n<h3>访问基类</h3>\n<p>可以通过 <a href=\"http://base.XXX\">base.XXX</a> 来访问</p>\n<pre><code>Console.WriteLine(base.MyStr);```\n\n### 覆写方法\n\n基类方法修饰符：virtual\n派生类方法修饰符:override\n</code></pre>\n<p>class MyBaseClass\n{\nvirtual public void Print(){\n...\n}\n}</p>\n<p>class MyDerivedClass : MyBaseClass\n{\noverride public void Print(){\n...\n}\n}```</p>\n<h3>构造函数初始化语句</h3>\n<pre><code>public MyDerivedClass(int x,string s) : base(x,s){//...}\npublic MyDerivedClass(int x,string s) : this(x,s){//...}```\n以上两种形式是语义等价的。\n也可以设置自定义的值\n</code></pre>\n<p>public MyDerivedClass(int x) : base(x,&quot;Hello World&quot;){//...}```</p>\n<h3>成员的可访问性</h3>\n<style>\ntable th:first-of-type {\n\twidth: 100px;\n}\n</style>\n<table>\n<thead>\n<tr>\n<th>修饰符</th>\n<th>可访问性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public</td>\n<td>程序集内外都可以访问。</td>\n</tr>\n<tr>\n<td>private</td>\n<td>只能被它自己的类的成员访问；不能被其他的类访问，包括继承它的类。</td>\n</tr>\n<tr>\n<td>protected</td>\n<td>如同private访问级别，但它允许派生自该类的类访问该成员（即使程序集外部继承该类的类也能访问该成员）。</td>\n</tr>\n<tr>\n<td>internale</td>\n<td>成员对程序集内部的所有类可见，但对程序集外部的类不可见。</td>\n</tr>\n<tr>\n<td>protected internal</td>\n<td>成员对所有集成该类的类以及所有程序集内部的类可见。注意这是 protected 和 internal 的并集，不是交集。</td>\n</tr>\n</tbody>\n</table>\n<h3>抽象成员</h3>\n<p>抽象成员必须是函数成员，即字段和常亮不能，但方法、属性、时间、索引是可以的。</p>\n<pre><code>abstract public void PrintStuff(string s);//分号替换实现\n\nabstract public int MyProperty//属性是可以抽象的\n{\n\tget;//分号替换实现\n\tset;//分号替换实现\n}```\n\n### 虚成员 和 抽象成员\n\n |虚成员 |  抽象成员  \n- | - | -\n关键字 | virtual | abstract \n实现体 | 有实现体 |没有实现体，被分号取代\n在派生类中被覆写 | 能被覆写，使用override | 必须被覆写，使用override\n成员的类型 | 方法、属性、事件、索引器 | 一样 \n\n### 抽象类可以有普通方法\n\n</code></pre>\n<p>abstract class AbClass\n{\npublic void IdentifyBase()\n{//...}\n}</p>\n<p>class DerivedClass : AbClass\n{\n//...\n}\n//调用\nDerivedClass dc = new DerivedClass();\ndc.IdentifyBase();//可行```</p>\n<h2>密封类</h2>\n<ul>\n<li>密封类只能被用作独立的类，它不能被用作基类。</li>\n<li>密封类使用sealed修饰符标注。</li>\n</ul>\n<pre><code>sealed class MyClass\n{\n\t//...\n}```\n\n\n## 静态类\n\n* 所有成员都是静态的\n* 静态类常见的用途：创建一个包含一组数学方法和值的数学库\n* 类本身必须标记为static\n* 类的所有成员必须是静态的\n* 类可以有一个静态构造函数，但不能有实例构造函数，不能创建该类的实例\n* 静态类是隐式密封的，也就是说，不能继承静态类\n\n## 扩展方法\n\n扩展方法允许编写的方法和声明它的类之外的类关联\n* 声明扩展方法的类必须声明为static\n* 扩展方法本身必须声明为static\n* 扩展方法必须包含关键字this作为它的第一个参数类型，并在后面跟着它所扩展的类的名称\n\n</code></pre>\n<p>sealed class MyData\n{\nprivate double D1,D2,D3;\npublic MyData(double d1,double d2,double d3)\n{D1 = d1;D2 = d2;D3 = d3;}</p>\n<pre><code>public double Sum(){return D1 + D2 + D3;}\n</code></pre>\n<p>}</p>\n<p>static class ExtendMyData\n{\n//声明为静态的\npublic static double Average(this MyData md)\n{\nreturn md.Sum() / 3;\n}\n}\n//调用\nMyData md = new MyData(3,4,5);\nConsole.WriteLine(md.Sum());\nConsole.WriteLine(md.Average());```</p>\n<h2>命名约定</h2>\n<table>\n<thead>\n<tr>\n<th>风格名称</th>\n<th>描述</th>\n<th>推荐使用</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Pascal大小写</td>\n<td>标识符中每个单词的首字母大写</td>\n<td>用于类型名称和类中对外可见成员的名称。涉及的名称包括：类、方法、命名空间、属性和公共字段</td>\n<td>CardDeck、Dealershand</td>\n</tr>\n<tr>\n<td>Camel大小写</td>\n<td>标识符中每个单词的首字母大写，第一个单词除外</td>\n<td>用于局部变量的名称和方法声明的形参名称</td>\n<td>totalCycleCount、randomSeedParam</td>\n</tr>\n<tr>\n<td>下划线加Camel大小写</td>\n<td>以下划线开头的Camel大小的标识符</td>\n<td>用于私有和受保护的字段</td>\n<td>_cycleCount、_selectedIndex</td>\n</tr>\n</tbody>\n</table>\n<h2>逻辑运算符</h2>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&amp;</td>\n<td>位与</td>\n<td>仅当两个操作位都是1时结果位才是1</td>\n</tr>\n<tr>\n<td></td>\n<td>位或</td>\n<td>只要任意一个操作位为1时结果位就是1</td>\n</tr>\n<tr>\n<td>^</td>\n<td>位异或</td>\n<td>仅当一个而不是两个操作数为1时结果位为1</td>\n</tr>\n<tr>\n<td>~</td>\n<td>位非</td>\n<td>操作数的每一位都取反。该操作得到操作数的二进制反码（也就是说，每个0都变成1，每个1都变成0。）</td>\n</tr>\n</tbody>\n</table>\n<h2>移位运算符</h2>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&lt;&lt;</td>\n<td>左移</td>\n<td>将位组向左移动给定数目个位置。位从左边移除并丢失。右边打开的位位置用0填充</td>\n</tr>\n<tr>\n<td>&gt;&gt;</td>\n<td>右移</td>\n<td>将位组向右移动给定数目个位置。位从右边移除并丢失</td>\n</tr>\n</tbody>\n</table>\n<h2>条件运算符</h2>\n<p>单行格式：</p>\n<pre><code>intVar = x &lt; y ? 5 : 10 ;```\n\n易读格式：\n</code></pre>\n<p>intVar = x &lt; y\n? 5\n: 10 ;```</p>\n<h2>用户定义的类型转换</h2>\n<pre><code>//隐式\n        必须                     目标类型           源数据\npublic static implicit operator TargetType (SourceType Identifier)\n{\n\t//...\n\treturn ObjectOfTargetType;\n}\n\n//显式 用explicit替换implicit\n\nclass LimitedInt\n{\n\t//将LimitedInt转换为int\n\tpublic static implicit operator int (LimitedInt li)\n\t{\n\t\treturn li.TheValue;\n\t}\n\t\n\t//将int转换为LimitedInt\n\tpublic static implicit operator LimitedInt (int x)\n\t{\n\t\tLimitedInt li = new LimitedInt();\n\t\tli.TheValue = x;\n\t\treturn li;\n\t}\n\t\n\tprivate int _theVlaue = 0;\n\tpublic int TheValue{ //... }\n}\n//调用\nLimitedInt li = 500;\nint value = li;\n//如果是 explicit(强制转换)\nLimitedInt li = (LimitedInt)500;\nint value = (int)li; ```\n\n\n## 运算符重载\n\n</code></pre>\n<p>class LimitedInt Return\n{\n必须的\t\t 类型\t  关键字   运算符              操作数\n-------------   ------    ------  \t---            --------------\npublic static LimitedInt operator    +        (LimitedInt x, double y)\n{\nLimitedInt li = new LimitedInt();\nli.TheValue = x.TheValue + (int)y;\nreturn li;\n}</p>\n<pre><code>public static LimitedInt - (LimitedInt x)\n{\n\t//在这个奇怪的类中，取一个值的负数等于0\n\tLimitedInt li = new LimitedInt();\n\tli.TheValue = 0;\n\treturn li;\n}\n</code></pre>\n<p>} ```</p>\n<h2>using语句</h2>\n<pre><code>using( ResourceType Identifier = Expression) Statement\n        ----------------------------------     ----\n\t\t            分配资源                  使用资源\n\t\t\t\t\t\nusing( TextWriter tw = File.CreateText(&quot;Lincoln.txt&quot;))\n{\n\ttw.WriteLine(&quot;写入XX语句&quot;);\n}\n\n//可以嵌套使用\n\n//场景1\nusing( ResourceType Id1 = Expr1 , Id2 = Expr2 , ...) EmbeddedStatement\n          \nusing( TextWriter tw1 = File.CreateText(&quot;Lincoln.txt&quot;),\n\t\t\t\t  tw2 = File.CreateText(&quot;Franklin.txt&quot;))\n{\n\ttw1.WriteLine(&quot;写入XX语句到文件1&quot;);\n\ttw2.WriteLine(&quot;写入XX语句到文件2&quot;);\n}\n\n//场景2\nusing( TextWriter tw = File.CreateText(&quot;Lincoln.txt&quot;))\n{\n\ttw.WriteLine(&quot;写入XX语句&quot;);\n\t\n\tusing( TextWriter tw2 = File.CreateText(&quot;Franklin.txt&quot;))\n\t{\n\t\ttw2.WriteLine(&quot;写入XX语句&quot;);\n\t}\n}\n\n\n//另一种形式的using - 不推荐\nusing( Expression) EmbeddedStatement\n\t\t------\n\t\t 资源\n\nTextWriter tw = File.CreateText(&quot;Lincoln.txt&quot;);\nusing( tw )\n{\n\ttw.WriteLine(&quot;写入XX语句&quot;);\t \n}\ntw.WriteLine(&quot;...&quot;);//运行时会报错，因为已经释放了\n\n综上，它也会对资源释放，释放后会导致不一致的状态。因此它提供了较少的保护，所以不推荐使用 ```\n       \n\n## 枚举\n\n在默认情况情况下，编译器把第一个成员赋值为0，并对每一个后续成员赋的值比前一个成员多一。\n\n</code></pre>\n<p>enum FaceCards\n{\nJack            = 11, // 11 显式设置\nQueen,                // 12 比之前的大1\nKing,                 // 13 比之前的大1\nNum             = 4,  // 4  显式设置.\nNum2,                 // 5  比之前的大1\nNum3            = Num // 14 以上定义了Num\n} ```</p>\n<h2>数组</h2>\n<h3>Clone浅复制</h3>\n<p>对于值类型数组和引用类型数组，都只复制元素，不会复制元素引用的对象。</p>\n<h2>委托</h2>\n<h3>匿名函数</h3>\n<h4>params参数</h4>\n<p>如果委托声明的参数列表包含了params参数，那么匿名方法的参数列表将忽略params关键字</p>\n<pre><code>delegate void SomeDel(int x,params int[] y);\n\nSomeDel mDel = delegate(int x int[] y){\n\t//...\n}; ```\n\n\n## 事件\n   \n\t   关键字    委托类型     事件名\n       -----     -------     --------\npublic event  EventHandler CountedADozen;\n\n\n## 接口\n\n### 显式接口成员实现\n\n</code></pre>\n<p>class MyClass : IIfc1,IIfc2\n{\nvoid IIfc1.PrintOut(string s)\n{\n//...\n}</p>\n<pre><code>void IIfc2.PrintOut(string s)\n{\n\t//...\n}\n</code></pre>\n<p>} ```</p>\n<h3>访问显式接口成员实现</h3>\n<pre><code>class MyClass : IIfc1\n{\n\tvoid IIfc1.PrintOut(string s)\n\t{\n\t\tconsole.WriteLine(&quot;IIfc1&quot;);\n\t}\n\t\n\tpublic void Method1()\n\t{\n\t\tPrintOut(&quot;...&quot;);               //编译错误\n\t\tthis.PrintOut(&quot;...&quot;);          //编译错误\n\t\t\n\t\t((IIfc1)this).PrintOut(&quot;...&quot;); //转换为接口引用 编译成功\n\t}\n} ```\n\n\n## 转换\n\n溢出检测上下文\n\nchecked(表达式)\nunchecked(表达式)\n\n</code></pre>\n<p>ushort sh = 2000;\nbyte sb;</p>\n<p>sb = unchecked((byte)sh); //大多数重要的位丢失了\nConsole.WriteLine(sb); //结果为 208</p>\n<p>sb = checked((byte)sh); //大多数重要的位丢失了\nConsole.WriteLine(sb); //抛出错误 System.OverflowException...</p>\n<p>//或者如下代码：\nbyte sb;\nushort sh = 2000;</p>\n<p>unchecked\n{\nsb = (byte)sh;\nConsole.WriteLine(sb);</p>\n<pre><code>checked\n{\n\tsb = (byte)sh;\n\tConsole.WriteLine(sb); \n}\n</code></pre>\n<p>} ```</p>\n<h2>as is 注意点</h2>\n<p>只能用于引用转换和装箱转换，不能用于用户自定义转换或到值类型的转换。</p>\n",
  "link": "\\zh-cn\\blog\\blog8.html",
  "meta": {
    "title": "C#笔记",
    "date": "2019-08-07 09:23:00",
    "categories": "[CSharp]"
  }
}